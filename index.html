<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Pong Responsivo</title>
  <style>
    :root {
      --bg1: #0e0f12;
      --bg2: #1a1f2b;
      --fg: #ffffff;
      --accent: #7dd3fc;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 800px at 70% 20%, var(--bg2), var(--bg1));
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--fg);
      overflow: hidden; /* Evita scroll al arrastrar en móvil */
    }

    /* Contenedor para centrar canvas y HUD */
    .stage {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
    }

    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
      /* nitidez en pantallas retina: se resuelve en JS ajustando el tamaño real */
    }

    /* HUD */
    .hud {
      position: fixed;
      top: env(safe-area-inset-top, 12px);
      left: 0;
      right: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      pointer-events: none;
      user-select: none;
      -webkit-user-select: none;
      font-weight: 600;
      letter-spacing: 1px;
      text-shadow: 0 2px 10px rgba(0,0,0,.6);
    }

    .score { font-size: clamp(18px, 4vw, 36px); opacity:.95; }

    .hint {
      position: fixed;
      bottom: env(safe-area-inset-bottom, 16px);
      left: 50%;
      transform: translateX(-50%);
      font-size: clamp(12px, 2.5vw, 16px);
      opacity: .7;
      text-align: center;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      backdrop-filter: blur(4px);
      pointer-events: none;
    }

    /* Overlay para pedir girar el celular */
    .rotate-overlay {
      position: fixed;
      inset: 0;
      display: none; /* por defecto oculto, se muestra con media query */
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.7);
      text-align: center;
      z-index: 10;
      padding: 24px;
    }
    .rotate-card {
      max-width: 520px;
      border-radius: 20px;
      padding: 24px 20px;
      background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));
      border: 1px solid rgba(255,255,255,0.2);
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    .rotate-card h1 {
      margin: 0 0 8px 0;
      font-size: clamp(18px, 5vw, 28px);
    }
    .rotate-card p {
      margin: 0;
      opacity: .85;
      font-size: clamp(14px, 3.5vw, 16px);
    }

    /* Mostrar overlay automáticamente en orientación vertical */
    @media (orientation: portrait) {
      .rotate-overlay { display: flex; }
    }

    /* Pequeño marcador central punteado (red de cancha) */
    .net {
      position: fixed;
      top: 0; bottom: 0; left: 50%; width: 2px;
      transform: translateX(-50%);
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,0.28),
        rgba(255,255,255,0.28) 12px,
        transparent 12px,
        transparent 24px
      );
      pointer-events: none;
    }

  </style>
</head>
<body>
  <div class="stage">
    <canvas id="game"></canvas>
  </div>
  <div class="net" aria-hidden="true"></div>

  <div class="hud">
    <div class="score" id="scoreLeft">0</div>
    <div class="score">—</div>
    <div class="score" id="scoreRight">0</div>
  </div>

  <div class="hint" id="hint">PC: W/S o ↑/↓ · Móvil: desliza en tu lado</div>

  <div class="rotate-overlay" id="rotate">
    <div class="rotate-card">
      <h1>Gira tu celular</h1>
      <p>Para jugar mejor, pon tu dispositivo en orientación horizontal.</p>
    </div>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreL = document.getElementById('scoreLeft');
    const scoreR = document.getElementById('scoreRight');
    const rotateOverlay = document.getElementById('rotate');

    // Estado del juego
    let W = 0, H = 0, DPR = Math.max(1, window.devicePixelRatio || 1);
    let running = true;

    const state = {
      ball: { x: 0, y: 0, vx: 0, vy: 0, r: 8 },
      paddleL: { x: 0, y: 0, w: 12, h: 90, vy: 0 },
      paddleR: { x: 0, y: 0, w: 12, h: 90, vy: 0 },
      scoreL: 0,
      scoreR: 0
    };

    // Ajusta tamaños en función de la pantalla
    function resize() {
      DPR = Math.max(1, window.devicePixelRatio || 1);
      const vw = Math.max(320, window.innerWidth);
      const vh = Math.max(320, window.innerHeight);

      // Canvas lógico
      W = vw; H = vh;

      // Canvas real en píxeles físicos para nitidez
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      canvas.width = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

      // Escala de elementos relativa al tamaño de pantalla
      const base = Math.min(W, H);
      state.ball.r = Math.max(6, Math.floor(base * 0.008));
      const paddleThickness = Math.max(10, Math.floor(base * 0.012));
      const paddleHeight = Math.max(70, Math.floor(base * 0.16));
      state.paddleL.w = state.paddleR.w = paddleThickness;
      state.paddleL.h = state.paddleR.h = paddleHeight;

      // Posiciones iniciales si el juego empieza o tras resize
      state.paddleL.x = Math.floor(W * 0.05);
      state.paddleR.x = Math.floor(W * 0.95) - state.paddleR.w;
      if (!serveInFlight) {
        centerBall();
      }

      // Mostrar/ocultar overlay también con JS por si el navegador no aplica la media query
      const isPortrait = vh > vw;
      rotateOverlay.style.display = isPortrait ? 'flex' : 'none';
    }

    window.addEventListener('resize', resize);
    window.addEventListener('orientationchange', resize);

    function centerBall(dir = Math.random() < 0.5 ? -1 : 1) {
      state.ball.x = W / 2;
      state.ball.y = H / 2;
      // Velocidad basada en tamaño de pantalla
      const speed = Math.max(220, Math.min(W, H) * 0.45); // px/s
      const angle = (Math.random() * 0.6 - 0.3); // ligeramente inclinado
      state.ball.vx = Math.cos(angle) * speed * dir;
      state.ball.vy = Math.sin(angle) * speed;
    }

    // Controles teclado (PC)
    const keys = new Set();
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp','ArrowDown','KeyW','KeyS',' '].includes(e.code)) e.preventDefault();
      keys.add(e.code);
      if (e.code === 'Space') togglePause();
    });
    document.addEventListener('keyup', (e) => keys.delete(e.code));

    // Controles táctiles (móvil): arrastra en tu mitad para mover la paleta correspondiente
    const activeTouches = new Map(); // id -> {side: 'L'|'R'}

    function handleTouch(e) {
      for (const t of e.changedTouches) {
        const rect = canvas.getBoundingClientRect();
        const x = t.clientX - rect.left;
        const y = t.clientY - rect.top;
        const side = x < rect.width / 2 ? 'L' : 'R';
        if (e.type === 'touchstart') {
          activeTouches.set(t.identifier, { side });
          movePaddleTo(side, y);
        } else if (e.type === 'touchmove') {
          const meta = activeTouches.get(t.identifier);
          if (meta) movePaddleTo(meta.side, y);
        } else if (e.type === 'touchend' || e.type === 'touchcancel') {
          activeTouches.delete(t.identifier);
          // frenado suave
          if (side === 'L') state.paddleL.vy = 0; else state.paddleR.vy = 0;
        }
      }
    }

    function movePaddleTo(side, targetY) {
      const p = side === 'L' ? state.paddleL : state.paddleR;
      const desired = Math.max(p.h/2, Math.min(H - p.h/2, targetY));
      // Ajusta velocidad para seguir el dedo
      p.vy = (desired - p.y) * 12; // ganancia fuerte para respuesta rápida
      p.y = desired;
    }

    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleTouch(e); }, { passive: false });
    canvas.addEventListener('touchmove',  (e) => { e.preventDefault(); handleTouch(e); }, { passive: false });
    canvas.addEventListener('touchend',   (e) => { e.preventDefault(); handleTouch(e); }, { passive: false });
    canvas.addEventListener('touchcancel',(e) => { e.preventDefault(); handleTouch(e); }, { passive: false });

    // AI simple opcional (si no hay toques/teclas en el lado derecho, puede asistir)
    let assistRight = true;

    // Pausa al cambiar de pestaña
    document.addEventListener('visibilitychange', () => { if (document.hidden) running = false; });

    function togglePause() { running = !running; lastTime = performance.now(); loop(lastTime); }

    // Lógica de juego
    let lastTime = 0;
    let serveInFlight = false;

    function update(dt) {
      // Entrada teclado para paletas
      const speedPaddle = Math.max(240, H * 0.7); // px/s
      let inputL = 0, inputR = 0;
      if (keys.has('KeyW') || keys.has('ArrowUp')) inputL -= 1;
      if (keys.has('KeyS') || keys.has('ArrowDown')) inputL += 1;
      // Permite jugar 2P en PC: flechas mueven derecha
      if (keys.has('ArrowUp')) inputR -= 1;
      if (keys.has('ArrowDown')) inputR += 1;

      if (inputL !== 0) { state.paddleL.vy = inputL * speedPaddle; }
      if (inputR !== 0) { state.paddleR.vy = inputR * speedPaddle; assistRight = false; }

      // Movimiento de paletas con límites
      state.paddleL.y = clamp(state.paddleL.y + state.paddleL.vy * dt, state.paddleL.h/2, H - state.paddleL.h/2);
      state.paddleR.y = clamp(state.paddleR.y + state.paddleR.vy * dt, state.paddleR.h/2, H - state.paddleR.h/2);

      // Asistencia IA para derecha si no hay controles activos
      if (assistRight && activeTouches.size === 0 && inputR === 0) {
        const target = state.ball.y;
        const follow = 0.12; // suavizado
        state.paddleR.y += (target - state.paddleR.y) * follow;
      }

      // Movimiento de la bola
      state.ball.x += state.ball.vx * dt;
      state.ball.y += state.ball.vy * dt;

      // Rebotes en techo/suelo
      if (state.ball.y - state.ball.r <= 0 && state.ball.vy < 0) { state.ball.vy *= -1; state.ball.y = state.ball.r; }
      if (state.ball.y + state.ball.r >= H && state.ball.vy > 0) { state.ball.vy *= -1; state.ball.y = H - state.ball.r; }

      // Colisiones con paletas
      collideWithPaddle(state.paddleL, 1);
      collideWithPaddle(state.paddleR, -1);

      // Puntos
      if (state.ball.x < -40) { // punto derecha
        state.scoreR++; scoreR.textContent = state.scoreR; serve(false); }
      if (state.ball.x > W + 40) { // punto izquierda
        state.scoreL++; scoreL.textContent = state.scoreL; serve(true); }
    }

    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

    function collideWithPaddle(p, dir) {
      // dir: 1 para izquierda (bola moviéndose hacia la derecha), -1 para derecha
      const bx = state.ball.x, by = state.ball.y, r = state.ball.r;
      const px = p.x, py = p.y, pw = p.w, ph = p.h;

      // AABB de paleta
      const left = px, right = px + pw, top = py - ph/2, bottom = py + ph/2;

      // ¿intersección?
      if (bx + r > left && bx - r < right && by + r > top && by - r < bottom) {
        // Rebote: invierte vx y añade efecto según dónde golpea
        const hitPos = (by - py) / (ph/2); // -1 arriba, 0 centro, 1 abajo
        const speed = Math.hypot(state.ball.vx, state.ball.vy);
        const newAngle = hitPos * 0.8; // máximo ~46°
        const newVx = Math.cos(newAngle) * speed * (dir);
        const newVy = Math.sin(newAngle) * speed;
        state.ball.vx = Math.sign(-dir) * Math.abs(newVx); // asegúrate de que salga en la dirección correcta
        state.ball.vy = newVy;

        // Empuja la bola fuera de la paleta para evitar quedarse pegada
        if (dir === 1) state.ball.x = right + r + 0.5; else state.ball.x = left - r - 0.5;

        // Aumenta ligeramente la velocidad tras cada golpe
        const boost = 1.04;
        state.ball.vx *= boost; state.ball.vy *= boost;
      }
    }

    function serve(toLeft = Math.random() < 0.5) {
      serveInFlight = true;
      centerBall(toLeft ? -1 : 1);
      // Pequeña pausa de saque
      running = false;
      setTimeout(() => { running = true; serveInFlight = false; }, 600);
    }

    function draw() {
      // Fondo sutil con viñeta
      ctx.clearRect(0, 0, W, H);

      // Paddles
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      drawRoundedRect(state.paddleL.x, state.paddleL.y - state.paddleL.h/2, state.paddleL.w, state.paddleL.h, 6);
      drawRoundedRect(state.paddleR.x, state.paddleR.y - state.paddleR.h/2, state.paddleR.w, state.paddleR.h, 6);

      // Ball
      ctx.beginPath();
      ctx.arc(state.ball.x, state.ball.y, state.ball.r, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawRoundedRect(x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y,     x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x,     y + h, r);
      ctx.arcTo(x,     y + h, x,     y,     r);
      ctx.arcTo(x,     y,     x + w, y,     r);
      ctx.closePath();
      ctx.fill();
    }

    function loop(ts) {
      if (!running) { requestAnimationFrame(loop); return; }
      const dt = Math.min(0.034, (ts - lastTime) / 1000 || 0.016);
      lastTime = ts;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    // Inicializa posiciones y arranca
    function init() {
      resize();
      // Coloca paletas al centro
      state.paddleL.y = H / 2;
      state.paddleR.y = H / 2;
      centerBall(Math.random() < 0.5 ? -1 : 1);
      running = true;
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }

    // Arranca cuando el contenido está listo
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  })();
  </script>
</body>
</html>
