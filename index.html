<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Pong Responsivo</title>
  <style>
    :root {
      --bg1: #0e0f12;
      --bg2: #1a1f2b;
      --fg: #ffffff;
      --accent: #7dd3fc;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 800px at 70% 20%, var(--bg2), var(--bg1));
      font-family: sans-serif;
      color: var(--fg);
      overflow: hidden;
    }

    .stage {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
    }

    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
    }

    .hud {
      position: fixed;
      top: 12px;
      left: 0;
      right: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      pointer-events: none;
      font-weight: 600;
      letter-spacing: 1px;
      text-shadow: 0 2px 10px rgba(0,0,0,.6);
    }

    .score { font-size: clamp(18px, 4vw, 36px); }

    .hint {
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      font-size: clamp(12px, 2.5vw, 16px);
      opacity: .7;
      text-align: center;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      backdrop-filter: blur(4px);
      pointer-events: none;
    }

    .rotate-overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.7);
      text-align: center;
      z-index: 10;
      padding: 24px;
    }
    .rotate-card {
      max-width: 520px;
      border-radius: 20px;
      padding: 24px 20px;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.2);
    }

    @media (orientation: portrait) {
      .rotate-overlay { display: flex; }
    }

    .net {
      position: fixed;
      top: 0; bottom: 0; left: 50%; width: 2px;
      transform: translateX(-50%);
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,0.28),
        rgba(255,255,255,0.28) 12px,
        transparent 12px,
        transparent 24px
      );
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="stage">
    <canvas id="game"></canvas>
  </div>
  <div class="net"></div>
  <div class="hud">
    <div class="score" id="scoreLeft">0</div>
    <div class="score">—</div>
    <div class="score" id="scoreRight">0</div>
  </div>
  <div class="hint">PC: W/S o ↑/↓ · Móvil: desliza en tu lado</div>
  <div class="rotate-overlay" id="rotate">
    <div class="rotate-card">
      <h1>Gira tu celular</h1>
      <p>Para jugar mejor, pon tu dispositivo en orientación horizontal.</p>
    </div>
  </div>
  <script>
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreL = document.getElementById('scoreLeft');
    const scoreR = document.getElementById('scoreRight');
    const rotateOverlay = document.getElementById('rotate');
    let W = 0, H = 0, DPR = 1;
    let running = true;

    const state = {
      ball: { x: 0, y: 0, vx: 0, vy: 0, r: 8 },
      paddleL: { x: 0, y: 0, w: 12, h: 90, vy: 0 },
      paddleR: { x: 0, y: 0, w: 12, h: 90, vy: 0 },
      scoreL: 0,
      scoreR: 0
    };

    function resize() {
      DPR = Math.max(1, window.devicePixelRatio || 1);
      W = window.innerWidth;
      H = window.innerHeight;
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      canvas.width = W * DPR;
      canvas.height = H * DPR;
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      state.paddleL.x = W * 0.05;
      state.paddleR.x = W * 0.95 - state.paddleR.w;
      const isPortrait = H > W;
      rotateOverlay.style.display = isPortrait ? 'flex' : 'none';
    }

    function centerBall(dir = 1) {
      state.ball.x = W / 2;
      state.ball.y = H / 2;
      const speed = 300;
      const angle = (Math.random() * 0.6 - 0.3);
      state.ball.vx = Math.cos(angle) * speed * dir;
      state.ball.vy = Math.sin(angle) * speed;
    }

    const keys = new Set();
    document.addEventListener('keydown', e => keys.add(e.code));
    document.addEventListener('keyup', e => keys.delete(e.code));

    const activeTouches = new Map();
    function handleTouch(e) {
      for (const t of e.changedTouches) {
        const rect = canvas.getBoundingClientRect();
        const x = t.clientX - rect.left;
        const y = t.clientY - rect.top;
        const side = x < rect.width / 2 ? 'L' : 'R';
        if (e.type === 'touchstart' || e.type === 'touchmove') {
          movePaddleTo(side, y);
        }
      }
    }
    function movePaddleTo(side, targetY) {
      const p = side === 'L' ? state.paddleL : state.paddleR;
      p.y = Math.max(p.h/2, Math.min(H - p.h/2, targetY));
    }
    canvas.addEventListener('touchstart', handleTouch, { passive: false });
    canvas.addEventListener('touchmove', handleTouch, { passive: false });

    function update(dt) {
      const speedPaddle = 300;
      if (keys.has('KeyW')) state.paddleL.y -= speedPaddle * dt;
      if (keys.has('KeyS')) state.paddleL.y += speedPaddle * dt;
      if (keys.has('ArrowUp')) state.paddleR.y -= speedPaddle * dt;
      if (keys.has('ArrowDown')) state.paddleR.y += speedPaddle * dt;

      state.paddleL.y = Math.max(state.paddleL.h/2, Math.min(H - state.paddleL.h/2, state.paddleL.y));
      state.paddleR.y = Math.max(state.paddleR.h/2, Math.min(H - state.paddleR.h/2, state.paddleR.y));

      state.ball.x += state.ball.vx * dt;
      state.ball.y += state.ball.vy * dt;

      if (state.ball.y - state.ball.r <= 0 || state.ball.y + state.ball.r >= H) {
        state.ball.vy *= -1;
      }

      collideWithPaddle(state.paddleL, 1);
      collideWithPaddle(state.paddleR, -1);

      if (state.ball.x < 0) { state.scoreR++; scoreR.textContent = state.scoreR; centerBall(1); }
      if (state.ball.x > W) { state.scoreL++; scoreL.textContent = state.scoreL; centerBall(-1); }
    }

    function collideWithPaddle(p, dir) {
      const bx = state.ball.x, by = state.ball.y, r = state.ball.r;
      const px = p.x, py = p.y, pw = p.w, ph = p.h;
      const left = px, right = px + pw, top = py - ph/2, bottom = py + ph/2;
      if (bx + r > left && bx - r < right && by + r > top && by - r < bottom) {
        const hitPos = (by - py) / (ph/2);
        const speed = Math.hypot(state.ball.vx, state.ball.vy);
        let newAngle = hitPos * 0.7;
        const minHoriz = 0.25;
        if (Math.abs(Math.cos(newAngle)) < Math.cos(minHoriz)) {
          newAngle = Math.sign(newAngle) * (Math.PI/2 - minHoriz);
        }
        state.ball.vx = Math.cos(newAngle) * speed * dir;
        state.ball.vy = Math.sin(newAngle) * speed;
        if (dir === 1) state.ball.x = right + r; else state.ball.x = left - r;
      }
    }

    function draw() {
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = 'white';
      ctx.fillRect(state.paddleL.x, state.paddleL.y - state.paddleL.h/2, state.paddleL.w, state.paddleL.h);
      ctx.fillRect(state.paddleR.x, state.paddleR.y - state.paddleR.h/2, state.paddleR.w, state.paddleR.h);
      ctx.beginPath();
      ctx.arc(state.ball.x, state.ball.y, state.ball.r, 0, Math.PI*2);
      ctx.fill();
    }

    let lastTime = 0;
    function loop(ts) {
      const dt = (ts - lastTime) / 1000;
      lastTime = ts;
      if (running) update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    function init() {
      resize();
      state.paddleL.y = H / 2;
      state.paddleR.y = H / 2;
      centerBall(Math.random() < 0.5 ? -1 : 1);
      requestAnimationFrame(loop);
    }

    window.addEventListener('resize', resize);
    window.addEventListener('orientationchange', resize);
    init();
  })();
  </script>
</body>
</html>
